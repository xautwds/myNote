1.中断响应在CPU每条指令最后一个时刻检查中断寄存器 ， 若有中断而且响应级别高于当前CPU的执行级别 ， 则进行中断。
2.进入中断需要进行现场保护 ， 退出中断会进行现场恢复 ， 现场信息指的是中断时刻能确保程序继续运行的信息。
3.异常是因为指令本身发生错误 ， 转入操作系统的异常处理程序。
4.核心态：此状态可访问内存任何地方 ， 系统空间和用户态都可以 。用户态只能访问用户空间。
5.中断向量：操作系统和硬件的接口 。 
6.产生中断时 ， 先将pc，ps压栈 ， 再根据中断向量表得到新的ps ， pc送入到ps ， pc寄存器 ， 总之用到那个寄存器就要进行压栈。
7.现场恢复：退栈 ， 将pc ，ps装入到pc ，ps寄存器。
8.pc：程序计数器，指向马上执行的指令。 
  ps：处理机状态字 ，寄存处理机运行状态的字 ：当前处理机运行态， 处理机优先级，各种控制位 。

9.C库函数封装了系统调用 ， 系统调用使用trap内陷 ， 使得用户态进入内核态 ， trap陷入时使用寄存器传递参数 ， 
  使用系统调用号 ， 得到使用的系统调用。
10.用户态程序调用C库程序--》系统调用库函数--》内核（数据压入用户核心栈中保存现场）--》系统调用处理总控 
--》区分系统调用，使用系统调用号（系统调用号寄存器区分）--》调用驱动程序 --》驱动请求（硬件）--》完成后发送中断给CPU--》返回
--》内核总控现场恢复--》返回到用户程序

11.进程由管理进程的PCB表和进程映像 。进程控制块PCB是系统管理控制进程的信息集合。
12.进程存在用户栈和核心栈 ，陷入内核使用核心栈。

13.PCB（进程控制块）：
	进程标识信息（本进程的标识） ， 
        处理机状态保存信息（核心栈）保存操作系统内核的运行现场信息
        进程控制信息，比如进程优先级 ，进程状态 ，进程间通讯信息。
14.进程创建过程：接受进程运行参数--》请求分配PCB--》初始化PCB表--》初始化进程空间（程序段数据段等等）
--》初始化一个栈设置线程保护区--》设置和父进程关系--》设置成就绪状态--》PCB进入进程队列
15.进程结束过程：进入结束状态--》关闭打开的文件，设备--》释放进程关联--》清理链接关系
--》比如子进程链到1号进程--》释放进程映像--》释放PCB--》调度切换
16.进程挂起意味着进程可以不占用内存 ， 处于挂起状态的进程映像在磁盘上。
   阻塞时进程挂起 ， 当阻塞挂起事件发生变成就绪挂起--》分配内存后变成就绪状态。	
17.进程切换过程：保存处理机上下文--》修改当前进程控制块--》选择另外一个进程（调度算法）--》修改被调度的进程控制块
--》恢复被选进程
18.进程调度特指进程占用处理机 ， 进程调度在核心态中运行。
19.引起调度的原因：
	进程的主动放弃CPU
	有新就绪的进程出现了
	进程时间片到，或优先级改变
20.调度时机：
	发生引起调度的条件，而且当前进程无法运行
	中断处理结束或者系统调用结束，返回到中断进程用户态之前
	实时系统还有其他调度
21.进程调度算法：
	FCFS:先到先处理，谁先到处理机就分给谁。
	短进程优先：取下一个运行时间最短的进程，降低平均等待时间。
	最高响应比：等待时间越长几率越大。可以解决长进程等待时间过长。R=(W+T)/T W等待时间  T运行时间
	优先级调度：选择优先级最高的占用进程处理机。
	轮转调度法：给进程分配时间片，用完就调出。 
22.fork：创建一个新进程，逻辑上复制共享父进程程序，父子进程返回都从返回点开始执行

23.临界段的硬件实现：
	（硬指令）屏蔽中断（单CPU），在执行程序之前屏蔽中断，执行完后开放中断。进程没有主动放弃执行，也没有中断响应，
程序就会执行，执行完后恢复中断。局限性：单CPU
	Test_and_Set指令：把内存单元读出来再置1，临界段之前加锁，出临界资源时解锁，它是一条指令，不会被打断，是原子操作。
因为Test_and_Set是一条指令，中断是在一条指令周期的最后时刻才能将指令打断，所以Test_and_Set不会被打断。
	Swap:lock和key进行交换，若lock是0则可以获取临界资源。
24.原语：完成某种功能不被分割，一气呵成的，可通过纯硬件实现，或者通过元方法
	屏蔽中断（单CPU）：单CPU实现pv操作。
	加硬锁（Test&set）
25.Reader/Writer访问问题：
	如果存在reader，则其他reader有较高优先权
	如果writer正在访问，其他都应该等待
26.进程间消息传递：
	共享存储，需要进程间安排互斥。
	消息传递：send，read系统调用
		直接传递：linux通过发送kill向进程发送信号。
		间接通信:消息队列，linux IPC消息传递机制，建立双向通讯。
27.死锁：进程集合中，每个进程都在等待事件发生，而事件又是进程集合中产生的，则发生死锁。
28.破坏死锁：
	破坏互斥占用条件：
		让资源共享，不独占（比如让显示器不独占使用），但有些资源必须独占。
	破坏占有等待条件：
		将进程所要资源直接分给进程，要么不给，要么全部满足。
		在下一轮进程申请时释放所占有资源。申请之前先释放。
	破坏非剥夺条件：
		要想申请资源，资源没有，把自己占有的资源让出。
		想要申请资源，资源没有，剥夺他人占有的资源。、
	破坏循环等待条件：
		采用顺序资源分配方法，给锁编号，先申请小号，再申请大号
29.死锁避免：申请资源时，如果满足申请，判断系统是否处于安全状态，如果处于，则同意申请，否则拒绝。
总资源数 - 已经分配的资源 >= 某进程需要的资源数
30.死锁避免：开销会很大，死锁避免只有理论价值，实际难以使用。系统很难知道你需要分配的资源数。










